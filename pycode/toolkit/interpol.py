#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from math import cos, pi
import sympy as sym
from toolkit.linearsol import thomas_tridiagonal_solve


def neville_interpolation(x_list: list, y_list: list):
    """ Neville interpolation:
    :return: child function, generated by interpolation.
    """
    length = len(x_list)
    if length != len(y_list):
        raise ValueError('Neville interpolation Error:'
                         'Length of x_list != y_list')

    # T_jk index convention: liuchuan's Numerical.pdf, ver 0.98
    def child_function(x: float):
        # t_j0 ~ t[j], t[-1] = 0 for indexing
        t = [y_list[j] for j in range(length)] + [0]
        for k in range(1, length):
            try:   # for x at elsewhere, numerically superior!
                t = [0.] * k + [t[j]
                    + (t[j] - t[j - 1])
                        / ((x - x_list[j - k]) / (x - x_list[j]) - 1)
                            for j in range(k, length)]          # noqa: E126
            except ZeroDivisionError:   # for x in x_list
                t = [0.] * k + [(x - x_list[j - k]) * t[j]
                        / (x_list[j] - x_list[j - k])
                            for j in range(k, length)]          # noqa: E126
            t.append(k)
        return t[length - 1]
    return child_function


# Alternative formulation:
#   Use sympy to find the expression first, and then evaluate.
#   Thought it would be faster; Unfortunately it's not...
#   Turns out sympy is slow...
class SymbolicNevilleInterpolation(object):
    """ Symbolic Neville interpolation,
        for ease of adding additional pts. """

    def __init__(self, x_list: list, y_list: list):
        self.length = len(x_list)
        if self.length != len(y_list):
            raise ValueError('Symbolic Neville Error:'
                             'Length of x_list != y_list')

        self.xlist, self.ylist = x_list, y_list

        # T_jk index convention: liuchuan's Numerical.pdf, ver 0.98
        self.t_index = 0
        self.t = [y_list[j] for j in range(self.length)]

        x = sym.symbols('x')

        # Iteration of t ~ T[:][k] -> T[:][k+1] ~ t_new
        def t_new(j: int, k: int):
            return sym.expand(
                ( (x - self.xlist[j - k]) * self.t[j]
                  - (x - self.xlist[j]) * self.t[j - 1] )
                / (self.xlist[j] - self.xlist[j - k])
            )

        # Since old t is useless once t_new is generated,
        # OVERWRITE old t with t_new with no mercy!
        # Use t_index to keep track of `k` in T_jk
        for k in range(1, self.length):
            self.t = [0.] * k \
                + [ t_new(j, k) for j in range(k, self.length)]
            self.t_index += 1

        self.symfunction = sym.lambdify(x, self.t[self.length - 1])
        print('INFO: Symbolic Neville: Initialized!\n')

    def function(self, x0: float):
        return self.symfunction(x0)


def chebyshev_approximation(input_function, order: int):
    """ Chebyshev approximation, using Clenshaw's algorithm. """
    n = order

    def chebyshev_nodes(n: int, k: int, m=1):
        return cos(pi * m * (k + 0.5) / n)

    node_values \
        = [ input_function(chebyshev_nodes(n, k)) for k in range(n) ]
    c = [2 * sum([ node_values[k] * chebyshev_nodes(n, k, m)
                   for k in range(n) ]) / n
         for m in range(n)]

    # Clenshaw's algorithm: b as auxilary function.
    b = list(range(n))
    # Last two entries of b
    b += [0, 0]

    # Clenshaw's iteration
    def child_function(x: float):
        for k in range(n - 1, 0, -1):
            b[k] = (c[k] + 2 * x * b[k + 1] - b[k + 2])
        return c[0] * 0.5 + x * b[1] - b[2]
    return child_function


def cubic_spline_interpolation(x_list: list, y_list: list,
                               boundary_derivatives=None,
                               boundary_moments=(0, 0)):

    """ Cubic spline with various boundary conditions.
        :param boundary_derivatives: default to None;
            boundary_derivatives[0]: left boundary value;
            boundary_derivatives[1]: right boundary value;
                when specified they takes precedence over `boundary_moments`.
        :param boundary_moments: (0, 0) ~ natural boundary
    """

    length = len(x_list)
    if length != len(y_list):
        raise ValueError('Cubic spline interpolation failed:'
                         'Length of x_list != y_list')

    # Get stepsize
    h = []
    for i in range(length - 1):
        h_next = x_list[i + 1] - x_list[i]
        if h_next < 0:
            raise ValueError('Cubic spline stepsize error:'
                             'x_list is not monotonically increasing.')
        h.append(h_next)

    # m ~ tridiagonal matrix, without boundary
    diag = [1.] + [(h[j - 1] + h[j]) / 3 for j in range(1, length - 1)] + [1.]
    # Indexed with row index
    lower = [0.] + [h[j - 1] / 6 for j in range(1, length - 1)] + [0.]
    upper = [0.] + [h[j] / 6 for j in range(1, length - 1)]

    try:
        rhs = ( [ boundary_moments[0] ]
                + [ (y_list[j + 1] - y_list[j]) / h[j]
                    - (y_list[j] - y_list[j - 1]) / h[j - 1]
                    for j in range(1, length - 1) ]
                + [ boundary_moments[1] ] )
    except IndexError:
        raise ValueError("Illegal bound moments.")

    if boundary_derivatives is not None:
        try:
            diag[0] = h[0] / 3
            upper[0] = h[0] / 6
            rhs[0] = (y_list[1] - y_list[0]) / h[0] - boundary_derivatives[0]
            diag[-1] = h[-1] / 3
            lower[-1] = h[-1] / 6
            rhs[-1] = boundary_derivatives[1] \
                - (y_list[-1] - y_list[-2]) / h[-1]
        except IndexError:
            raise ValueError("Cubic spline: illegal boundary derivatives.")

    # Invoke thomas_tridiagonal_solve() from `linearsol`
    m = thomas_tridiagonal_solve(diag, upper, lower, rhs)
    # Const of integration:
    int_const_a \
        = [ (y_list[j + 1] - y_list[j]) / h[j]
            - h[j] * (m[j + 1] - m[j]) / 6 for j in range(length - 1) ]
    int_const_b \
        = [ y_list[j] - m[j] * h[j]**2 / 6 for j in range(length - 1) ]

    def child_function(x: float):
        # Find j-index of x
        j_right = length - 2
        j_left = 0
        j = int(j_right / 2)
        while j_right - j_left > 1:
            if x_list[j + 1] > x:
                j_right = j
            else:
                j_left = j
            j = int((j_left + j_right) / 2)
        if x_list[j_right] < x:
            j = j_right
        else:
            j = j_left

        return ( m[j] * (x_list[j + 1] - x)**3 / h[j] / 6
                 + m[j + 1] * (x - x_list[j])**3 / 6 / h[j]
                 + int_const_a[j] * (x - x_list[j]) + int_const_b[j] )

    return child_function
